# --- ВВОДНЫЕ ---
Входные параметры:
```
    - z             : [B, N]            (complex)
    - z_j           : [B, M, N]         (complex)
    - vec_d         : [B, N]            (same dtype as z)
    - vec_d_j       : [B, M, N]         (same dtype as z)
    - T_hat_j       : [B, M, S]         (complex, contributes to final T)
    - alpha_j       : [B, M]            (real)
    - sigma_par     : [B, M]            (real; parallel scale)
    - sigma_perp    : [B, M]            (real; perpendicular scale)
	...
	(дополнительные параметры — опционально)
```

Условия валидности:
- Численная эквивалентность результатов (в пределах допусков) с T_classic_window() или T_classic_full() на идентичных входных данных.
- Контролируемый уровень предельной ошибки. Базовый допуск: 1.0e-4.

Требования:
- Линейность по памяти по N, M.
- Линейность по вычислительной сложности по N, M.
- Поддержка высоких размерностей N (> 128) и M (> 4096) в пределах минимальной утилизации ресурсов (для этого нужна линейность по памяти и по вычислительной сложности по N и M).

Ограничения:
- Не использовать прямую суммацию по решётке.
- Не использовать cosh().
- Отсутствие кеша.
- Отсутствие материализации тензоров (везде, где возможно).

Разрешено:
- Прибегать к любым методам оптимизации.
- Нарушать гладкость градиента или полностью его разрывать.
- Переформулировать теорию CPSF при условии сохранения численной эквивалентности результатов с классическими методами расчёта (численная эквивалентность CPSF).

Подсказки:
Theta-функции (1D), omega-функции, Гаусс-Эрмит, Эрмит-Кленшоу, разложение Чебышёва, Пуассоновская суммация, разложение в ряды.

# --- ДОПОЛНЕНИЕ ---

Переходим в режим брейн-шторма: наша задача разработать столь же эффективный метод учёта хвостов.

Требования:
1. Быстрый и дешёвый по памяти для больших N (под большими я подразумеваю размерности порядка 1024 и выше). Желательно, вообще линейный по M и N, или даже O(1).
2. Без python-циклов. Только векторизуемые операции.
3. Без сумм по решёткам или модам.
4. Без материализации больших тензоров.
5. Без возникновения квадратичных размерностей.
6. Численная устойчивость и отсутствие возникновения экстримальных значений.
7. Никаких степеней/экспонент, где экспонента зависит от N, иначе возможны взрывы.
8. Никаких cosh иначе снова взрывы.

Что мы *уже* знаем и можем использовать:
1. Мы точно знаем значение нулевого фрейма.
2. Наши сигмы линейны — затухание идёт, как 1/sigma_(par||perp).
3. Нам точно известны характеристики гауссианы вклада.
4. Нам точно известно место нашего замера и значение поля в этом месте.
5. Нам доступны промежуточные рассчёты нулевого фрейма.

Возможные подсказки:
1. Объёмная разность реальной анизотропной гауссианы вклада и "виртуальной" изотропной/анизотропной псевдогауссианы из точки замера и полученного значения поля.
2. Производные первого- и второго- порядков исходной анизотропной гауссианы вклада в точке замера, как точные корректирующие факторы дла построения изотропной псевдогауссианы (для расчёта разницы), или как базовые факторы для рассчёта корректирующих факторов хвостов исходной гауссианы. 

Дополнительные условия (разрешения) для тебя:
Даю тебе "зелёный" свет на введение новых концептов, алгоритмов, методов, эквивалентностей и любых других дополнений и уточнений, при условии сохранения итоговой численной эквивалентности и точности рассчётов. Это значит, ты можешь включить творческий подход на полную катушку, коллега, если это поможет решить задачу. Для начала — подумай, что мы уже сейчас знаем и имеем и как мы можем это креативно применить для элегантных и точных шорткатов в рассчётах.

*ВАЖНО*: Координата z — позиционная часть — периодизуется **полностью** и по вещественной (real) и по мнимой (imag) части. Направленическая часть — *не* периодизуется. Это два разных блока: [POS-x-DIR].
